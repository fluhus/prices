// Handles data reporting and bouncing. Reports data in CSV files, while
// bouncing off repeating data entries.
//
// Prior to calls to this package, one should call the Initialize() function.
// After finishing, one should call Finalize() to ensure all buffers are
// flushed and all resources are released. Multiple rounds of Initialize and
// Finalize are allowed.
//
// Input data to this package should be sorted ascendingly by time, to allow
// proper bouncing.
package bouncer

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"hash/crc64"
	"os"
	"strconv"
)

// Root path for data output.
var outDir string

// Initializes the bouncing mechanism. Should be called prior to any call to the
// package.
func Initialize(dir string) {
	outDir = dir
	initPersistence()
	initItems()
	initItemsMeta()
	initPrices()
	initStores()
	initStoresMeta()
	initPromos()
	state = nil
}

// Flushes and closes all streams used by this package, and terminates all
// goroutines. Should be called after using the package to ensure all data were
// written and no goroutines leak.
func Finalize() {
	state = &stateType{}
	finalizeItems()
	finalizeItemsMeta()
	finalizePrices()
	finalizeStores()
	finalizeStoresMeta()
	finalizePromos()
	finalizePersistence()
}

// Used for hashing stuff.
var crcTable = crc64.MakeTable(crc64.ECMA)

// Returns the hash generated by printing the given arguments one after another.
func hash(a interface{}, b ...interface{}) int {
	crc := crc64.New(crcTable)
	fmt.Fprint(crc, append([]interface{}{a}, b...)...)
	return int(crc.Sum64())
}

// A buffered closable file writer.
type fileWriter struct {
	f             *os.File    // Underlying file.
	csv           *csv.Writer // For writing CSV.
	*bufio.Writer             // For direct writing.
}

// A buffered closable file reader.
type fileReader struct {
	f *os.File
	*bufio.Reader
}

func (w *fileWriter) Close() {
	w.csv.Flush()
	w.Flush()
	w.f.Close()
}

func (r *fileReader) Close() {
	r.f.Close()
}

func newFileWriter(file string) (*fileWriter, error) {
	f, err := os.Create(file)
	if err != nil {
		return nil, err
	}
	buf := bufio.NewWriter(f)

	return &fileWriter{f, csv.NewWriter(buf), buf}, nil
}

func newFileAppender(file string) (*fileWriter, error) {
	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
	if err != nil {
		return nil, err
	}
	buf := bufio.NewWriter(f)
	return &fileWriter{f, csv.NewWriter(buf), buf}, nil
}

func newFileReader(file string) (*fileReader, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	buf := bufio.NewReader(f)
	return &fileReader{f, buf}, nil
}

// Prints the given values comma-separated, with a new line at the end.
func (w *fileWriter) printCsv(values ...interface{}) {
	records := make([]string, 0, len(values))
	for _, v := range values {
		records = append(records, fmt.Sprint(v))
	}
	w.csv.Write(records)
}

// Converts string to int and panics on failure.
func atoi(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		panic("Failed to parse number: " + err.Error())
	}
	return i
}

// Converts int to string.
func itoa(i int) string {
	return fmt.Sprint(i)
}
