// Handles data reporting and bouncing. Reports data in TSV files, while
// bouncing off repeating data entries.
//
// Prior to calls to this package, one should call the Initialize() function.
// After finishing, one should call Finalize() to ensure all buffers are
// flushed and all resources are released. Multiple rounds of Initialize and
// Finalize are allowed.
//
// Input data to this package should be sorted ascendingly by time, to allow
// proper bouncing.
package bouncer

import (
	"bufio"
	"fmt"
	"hash/crc64"
	"io"
	"os"
	"strconv"
)

// Root path for data output.
var outDir string

// Initializes the bouncing mechanism. Should be called prior to any call to the
// package.
func Initialize(dir string) {
	outDir = dir
	initPersistence()
	initItems()
	initItemsMeta()
	initPrices()
	initStores()
	initStoresMeta()
	initPromos()
	state = nil
}

// Flushes and closes all streams used by this package, and terminates all
// goroutines. Should be called after using the package to ensure all data were
// written and no goroutines leak.
func Finalize() {
	state = &stateType{}
	finalizeItems()
	finalizeItemsMeta()
	finalizePrices()
	finalizeStores()
	finalizeStoresMeta()
	finalizePromos()
	finalizePersistence()
}

// Used for hashing stuff.
var crcTable = crc64.MakeTable(crc64.ECMA)

// Returns the hash generated by printing the given arguments one after another.
func hash(a interface{}, b ...interface{}) int {
	crc := crc64.New(crcTable)
	fmt.Fprint(crc, append([]interface{}{a}, b...)...)
	return int(crc.Sum64())
}

// Prints the given values tab-separated, with a new line at the end.
func printTsv(w io.Writer, values ...interface{}) {
	for i := range values {
		if i == 0 {
			fmt.Fprintf(w, "%v", values[i])
		} else {
			fmt.Fprintf(w, "\t%v", values[i])
		}
	}
	fmt.Fprintf(w, "\n")
}

// A buffered closable file writer.
type fileWriter struct {
	file *os.File
	*bufio.Writer
}

// A buffered closable file reader.
type fileReader struct {
	file *os.File
	*bufio.Reader
}

func (f *fileWriter) Close() {
	f.Flush()
	f.file.Close()
}

func (f *fileReader) Close() {
	f.file.Close()
}

func newFileWriter(file string) (*fileWriter, error) {
	f, err := os.Create(file)
	if err != nil {
		return nil, err
	}
	buf := bufio.NewWriter(f)
	return &fileWriter{f, buf}, nil
}

func newFileAppender(file string) (*fileWriter, error) {
	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
	if err != nil {
		return nil, err
	}
	buf := bufio.NewWriter(f)
	return &fileWriter{f, buf}, nil
}

func newFileReader(file string) (*fileReader, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	buf := bufio.NewReader(f)
	return &fileReader{f, buf}, nil
}

// Converts string to int and panics on failure.
func atoi(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		panic("Failed to parse number: " + err.Error())
	}
	return i
}

// Converts int to string.
func itoa(i int) string {
	return fmt.Sprint(i)
}
